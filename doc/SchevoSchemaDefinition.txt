=============================
 Schema Definition Reference
=============================


.. sectnum::

.. contents::


Overview
========

A Schevo database is the combination of a schema definition, stored
data, and an engine that exposes the two.  This document describes in
detail the schema definition syntax used by Schevo.

Schema definitions are pure-Python modules that make use of Schevo's
syntax extensions.  Schema definitions can be directly imported
anywhere, but typically the import process is managed by the Schevo
database engine in order to tie a schema to an open database.

Stored data is managed by the `schevo.store` package, based on Durus_.
The data is kept in a general structure used by all Schevo databases,
described in the `internal database structures`_ reference.

The database engine is defined in the `schevo.database` module, and
provides read/write access to stored data using the higher-level
structures defined by the database's schema definition.

.. _Durus: http://www.mems-exchange.org/software/durus/

.. _internal database structures: reference-database.html


Doctest Setup
=============

This document also functions as a doctest::

    >>> from schevo.test import DocTest


Schema definition syntax
========================

This section describes the syntax used for schema definitions.


Reserved Words
--------------

The following cannot be used for field names in Entity class
definitions:

- Any single-letter name.  These are reserved for `Namespaces`.

- Any name beginning with an underscore.  These are reserved for
  private methods defined by Schevo.

- Any name beginning with a single letter and an underscore, such as
  ``t_something``.  These are used for query, transaction, view, and
  extender methods.

- ``classmethod``.  This is a decorator used to designate a method as
  attached to a namespace on an entity class's extent, and passed the
  entity class as the first argument when called.

- ``db``.  This contains the currently-open database that the schema
  is associated with.

- ``extentmethod``.  This is a decorator used to designate a method as
  attached to a namespace on an entity class's extent, and passed the
  entity class's extent as the first argument when called.

- ``schevo``.  This is imported into the global namespace.

- ``sys``.  This is used to expose standard public methods and
  properties of Schevo objects.


Preamble
--------

All schemata must begin with the following two lines::

  from schevo.schema import *
  schevo.schema.prep(locals())


Preamble Template
.................

A file is provided in the Schevo source distribution called
``SCHEMA-PREAMBLE.txt`` that contains the source code required for all
Schevo schemata, as well as some additional comments that assist in
starting a new database schema.


Icon Support
............

To include icon support in a database schema, add the following extent
definition::

  class SchevoIcon(E.Entity):

      _hidden = True

      name = f.unicode()
      data = f.image()

      _key(name)


Overall Structure
-----------------

A Schevo database schema consists of a series of the following types
of declarations:

- `Entity/extent definitions`_.

- `Field definitions`_.

- Key/index specifications.

- `Query definitions`_ and `query methods`_.

- `Transaction definitions`_ and `transaction methods`_.

- `View definitions`_ and `view methods`_.

- `Extension methods`_.

- Labels.

- `String representations`_.

- `Initial/sample data`_.

Code blocks defined in a schema make use of the Database API.


Schema globals
--------------

The following objects are available in the global Python namespace of
a schema module:

- ``d``: The `schevo.namespace.SchemaDefinition` associated with the
  schema module.

- ``db``: The currently-open `schevo.database.Database` that is using
  the schema module.


Global namespaces
.................

The following Schevo-managed namespaces are available in the global
Python namespace of a schema module.

Methods defined in the schema definition may use any part of the
`public API <reference-api.html>`__ exposed by the currently opened
database that is associated with the schema.

These namespaces cannot be directly modified.  Schevo manages them,
and automatically adds objects to them when it imports a schema
definition as a module.

- ``E``: `Entity <class-schevo.entity.Entity.html>`__ classes.  The
  standard Entity class is in this namespace by default. Each
  entity/extent definition in the schema is added to this namespace.
  See `entity/extent definitions`_.

- ``F``: `Field <class-schevo.field.Field.html>`__ classes.  The field
  classes defined in `schevo.field <module-schevo.field.html>`__ are
  in this namespace by default.  Custom field definitions in the
  schema are added to this namespace.  See `field definitions`_.

- ``f``: `FieldDefinition
  <class-schevo.fieldspec.FieldDefinition.html>`__ constructors.
  These correspond to the classes defined in the ``F`` namespace and
  are used to create lists of field definitions for entities, queries,
  transactions, and views. See `field definitions`_.

- ``Q``: `Query <class-schevo.query.Query.html>`__ classes.  The Query
  class, and all its subclasses defined in `schevo.query
  <module-schevo.query.html>`__, are in this namespace by default.
  Each Query class defined at the database level is added to this
  namespace.  See `query definitions`_.

- ``q``: Database-level query methods.  See `query methods`_.

- ``T``: `Transaction <class-schevo.transaction.Transaction.html>`__
  classes.  The Transaction class, and all its subclasses defined in
  `schevo.transaction <module-schevo.transaction.html>`__, are in this
  namespace by default. See `transaction definitions`_.

- ``t``: Database-level transaction methods.  See `transaction
  methods`_.

- ``V``: `View <class-schevo.view.View.html>`__ classes.  The View
  class, and all its subclasses defined in `schevo.view
  <module-schevo.view.html>`__, are in this namespace by default.
  Each View class defined at the database level is added to this
  namespace.  See `view definitions`_.


Entity/extent definitions
-------------------------

An entity/extent definition minimally consists of a subclass of
``E.Entity``::

    class Foo(E.Entity):
        """Description of Foo."""

The above example defines a ``Foo`` extent, which contains ``Foo``
entities that each have zero fields, as none were defined.

The entity/extent definition may further contain the following types
of declarations:

- `Field definitions`_.  Here is a ``Foo`` extent where each entity
  has a ``name`` field of ``unicode`` type, and a ``FooChild`` extent
  where each entity has a reference to a ``Foo`` entity and also has a
  ``bar`` field of ``integer`` type::

      class Foo(E.Entity):

          name = f.string()

      class FooChild(E.Entity):

          foo = f.entity('Foo')
          bar = f.integer()

- `Calculated field methods`_.  Here is a ``Gender`` extent whose
  entities have a ``count`` field of type ``integer`` that calculates
  the number of ``Person`` entities whose ``gender`` field references
  that ``Gender`` entity::

      class Gender(E.Entity):

          code = f.unicode()
          name = f.unicode()
          @f.integer()
          def count(self):
              return self.sys.count('Person', 'gender')

      class Person(E.Entity):
      
          name = f.unicode()
          gender = f.entity('Gender', required=False)
      
- Key/index specifications.  Here is a ``Person`` extent whose
  entities must have unique values for their ``name`` field, and that
  is also indexed by ``age`` then ``name``::

      class Person(E.Entity):

          name = f.unicode()
          age = f.integer()

          _key(name)
          _index(age, name)

- Extent-specific `query definitions`_ and `query methods`_.

- Entity/extent-specific `transaction definitions`_ and `transaction
  methods`_.

- Entity-specific `view definitions`_ and `view methods`_.

- Entity/extent-specific `extension methods`_.

- Extent labels.  Schevo creates a default singular and plural
  label for extents based on the class name used to define the
  extent.  This may be overridden in the class definition.  Here is a
  ``Person`` extent whose plural label is "People"::

      class Person(E.Entity):
          _plural = u'People'

  Here is a ``TpsReport`` extent whose singular label is
  "T.P.S. Report".  The default plural label is based on the singular
  label, so the plural label for this extent is "T.P.S. Reports"::

      class TpsReport(E.Entity):
          _label = u'T.P.S. Report'

- Entity `string representations`_.  Schevo user interfaces make use
  of string representations of entities when presenting short
  summaries of them.  The default string representation of an entity
  is the value of its ``name`` field if it has one, or the result of
  calling ``repr()`` on the entity if not.  Here is an example of
  a ``FooChild`` extent that has a custom string representation::

      class Foo(E.Entity):

          name = f.string()

      class FooChild(E.Entity):

          foo = f.entity('Foo')
          bar = f.integer()

          def __unicode__(self):
              return u'%s :: %s' % (self.foo, self.bar)

  In the above example, if a ``FooChild`` entity's ``bar`` field value
  was ``12``, and its ``foo`` value referenced a ``Foo`` entity whose
  ``name`` was ``u'abc'``, the result of calling ``unicode()`` on the
  ``FooChild`` entity would be ``u'abc :: 12'``.

- Extent `initial/sample data`_.


Extension methods
-----------------


Initial/sample data
-------------------

Initial and sample data for a child entity can be supplied by
specifying the value of the first key of the parent.  For example::

    class Foo(E.Entity):

        name = f.string()

        _key(name)

        _initial = [
            ('One', ),
            ('Two', ),
            ('Buckle', ),
            ('Shoe', ),
            ]

    class FooChild(E.Entity):

        foo = f.entity('Foo')
        bar = f.string()

        _key(foo, bar)

        _initial = [
            (('One',), 'This is how it starts.'),
            (('Shoe',), 'This is how it ends.'),
            (('Shoe',), 'Need to have two shoes.'),
            (('Shoe',), 'And one for a rainy day.'),
            ]

The appearance of a tuple tells the data generator to find a ``Foo``
entity whose first unique key matches the values supplied in the
tuple.


Field definitions
-----------------

Define a field for an Entity, Parameterized Query, Transaction, or
View by using a `field factory`.  Field factories are accessed using
the global `f` namespace.

The members of the `f` namespace are all of the available field types,
converted from their "CamelCase" names to "lowercase_with_underscores"
names, e.g. the `Boolean` field class becomes `f.boolean`, and the
`EntityList` field class becomes `f.entity_list`.

For example, this Entity subclass defines three fields::

    class Dog(E.Entity):
    
        name = f.unicode()                        # [1]
        birthdate = f.date(required=False)        # [2]
        disposition = f.entity('Disposition', on_delete=UNASSIGN,
                               required=False)    # [3]

1. The `name` field is a required `Unicode` field.  By default, all
   fields are required.

2. The `birthdate` field is an optional `Date` field.

3. The `disposition` field is an optional `Entity` field that can
   store a reference to a `Disposition` entity.  When the referenced
   `Disposition` entity is deleted, this field's value is set to
   `UNASSIGNED`. See also `cascading delete rules for Entity fields`_.


Calculated field methods
........................


Cascading delete rules for Entity fields
........................................

When defining an `Entity`, `EntityList`, `EntitySet`, or a custom
entity-storing field, you may specify cascade delete rules for that
field.

Upon receiving a request to delete an entity whose reference is stored
in one of these fields, Schevo will first check the rules of those
fields to see if the deletion is allowed and, if so, what should
happen to the field or entity that refers to the deleted entity.

The default rule of the `available rules`_ is `RESTRICT`, which is the
safest operation, since it prevents accidental deletion of an entity
if it is being referred to by another entity.


Specifying type-specific rules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Specify a rule for only a certain type of entity by giving the type
name and rule as a tuple to the field factory.

For example, to specify an `Entity` field that can refer to a `Cog` or
a `Sprocket` that allows cascade deletion when a `Cog` is deleted but
disallows deletion of a referred-to `Sprocket`, use this::

    part = f.entity(('Cog', CASCADE), ('Sprocket', RESTRICT))


Specifying default rules
~~~~~~~~~~~~~~~~~~~~~~~~

Specify a rule for all types of entities by giving a value to the
`on_delete` keyword argument to the field factory.

For example, to specify an `Entity` field that can refer to a `Cog`, a
`Sprocket`, or a `Widget`, but that requests field unassignment on
deletion of the referred entity, use this::

    part = f.entity('Cog', 'Sprocket', 'Widget', on_delete=UNASSIGN)


Available rules
~~~~~~~~~~~~~~~

* `CASCADE`: If entity `B` has a field that refers to entity `A`, and
  entity `A` is deleted, entity `B` will be deleted as well, provided
  that no other rules are restricting the deletion of entity `B`.

* `REMOVE`: If entity `B` has an `EntityList` or `EntitySet` field
  that contains a reference to entity `A`, and entity `A` is deleted,
  the reference to `A` will be removed from that field in `B`.

* `RESTRICT`: If entity `B` has a field that refers to entity `A`,
  Schevo will not allow deletion of entity `A`.

* `UNASSIGN`: If entity `B` has a field that refers to entity `A`, and
  entity `A` is deleted, the field containing the reference to `A`
  will be set to `UNASSIGNED`, if allowed.

  If the field definition in `B` is an `Entity` field, it must include
  ``required=False``.  If the field in `B` is a required field, then
  the unassignment will not work and the deletion will be restricted.

  If the field definition in `B` is an `EntityList` field, it must
  include ``allow_unassigned=True``. If the field in `B` does not
  allow `UNASSIGNED` to be a member of its collection, then the
  unassignment will not work and the deletion will be restricted.


Rule interaction
~~~~~~~~~~~~~~~~

There may be complex interactions between cascade deletion rules if
you have complex logic in your application.  Schevo is designed to
handle these in a consistent manner.  As of this writing, please see
the source for `schevo.transaction`, and the source for the
`test_on_delete` unit test, for further information.


Field types
-----------

Schevo contains many built-in field types typically used when building
a database schema.  You can also create `custom field types`_ when
your schema has unique requirements for data types.


HashedValue field type
......................

A **HashedValue** field, upon having its value set, will store a
one-way hash of that value.

You can use the `compare(value)` method of a `HashedValue` field to
see if the hash matches a value, but it is not possible to retrieve
the original value from the one-way hash.

This is useful for storing information about a user's password in a
reasonably secure manner, preventing immediate discovery of passwords
if a proprietary Schevo database were stolen or otherwise accessed by
unauthorized users.


String field types
..................

**String** fields are used to store Python ASCII strings. An
application may assume that a `String` field's value can be displayed
to a user as text.

**Path** fields are `String` fields used to store filesystem paths.


Unicode fields
..............

**Unicode** fields are used to store Unicode strings. An application
may assume that a `Unicode` field is a single-line field.

**Memo** fields are used to store Unicode strings. An application may
assume that a `Memo` field is identical in operation to a `Unicode`
field, but that it is a multiple-line field.

**Password** fields are used to store plaintext Unicode strings.  An
application may assume that the contents of a `Password` field should
not be displayed as plaintext.  **NOTE:** `Password` fields are not
necessarily secure.  You may wish to use the `HashedValue field type`_
instead.


Blob fields
...........

**Blob** fields are used to store binary large objects as Python
strings. An application should not assume that a `Blog` field can be
displayed to a user as text.

**Image** fields are `Blob` fields that store binary data for an
image.


Numeric fields
..............

**Integer** fields store integer values.

**Float** fields store floating point values.

**Money** fields store fixed-point fractional values, and are commonly
used to store values representing monetary amounts.


Date and time fields
....................

**Date** fields store `datetime.date` objects.

**Datetime** fields store `datetime.datetime` objects.


Boolean field
.............

A **Boolean** field stores a boolean value.


Entity fields
.............

An **Entity** field stores a reference to another entity.

An **EntityList** field stores a list of references to other entities.

An **EntitySet** field stores a set of references to other entities.


Custom field types
..................


Key and index specifications
----------------------------


Labels and plural labels
------------------------


String representations
----------------------


Query definitions
-----------------


Query methods
-------------

Add query methods to entity class definitions to provide access to
query classes.

For entity-level queries, a query method looks something like this,
where `factor` is an optional argument that can be given when the
query method is called, and `RelatedStuff` is a global query class
defined elsewhere::

    def q_related_stuff(self, factor=None):
        q = RelatedStuff()
        if factor is not None:
            q.factor = factor
        return q


Embedded simple queries
.......................

`Simple queries` are queries that do not take any parameters and are
not visibly composed of subqueries.  

Because of these properties, it is easy to embed a function within a
query method to expose simple queries, without having to write a
separate query class to hold the code that performs the query.

An embedded simple query looks something like this::

    def q_related_stuff(self):
        def fn():
            # ... Do stuff to build "results" ...
            return results
        return Q.Simple(fn, 'Related Stuff')


Transaction definitions
-----------------------


Customizing standard Create transactions
........................................

See `SchevoTransactionHookMethods`:trac:.


Customizing standard Delete transactions
........................................

See `SchevoTransactionHookMethods`:trac:.


Customizing standard Update transactions
........................................

See `SchevoTransactionHookMethods`:trac:.


Creating new transactions
.........................


Transaction methods
-------------------


View definitions
----------------


View methods
------------


..
     Local Variables:
     mode: rst
     End: 
