==================
 Schema Reference
==================

.. role:: raw-html(raw)
   :format: html

:Last Changed: $Date: 2005-10-22T21:57:34.410155Z $


(Note: This document is far from complete and is regularly updated and
reorganized.  This notice will be removed when the document has
matured and stabilized.)

Document Status: draft, in development

.. sectnum::

.. contents::


.. Doctest setup

   >>> import os
   >>> from schevo.test import CreatesSchema
   >>> tester = CreatesSchema()
   >>> db = None
   >>> def new_db(schema_source):
   ...     global db
   ...     if db is not None:
   ...         tester.tearDown()
   ...     tester.schema = schema_source
   ...     tester.setUp()
   ...     db = tester.db


Overview
========

A Schevo database is the combination of a schema definition, stored
data, and an engine that exposes the two.  This document describes in
detail the schema definition syntax used by Schevo.

Schema definitions are pure-Python modules that make use of Schevo's
syntax extensions.  Schema definitions can be directly imported
anywhere, but typically the import process is managed by the Schevo
database engine in order to tie a schema to an open database.

Stored data is managed by the `schevo.store` package, based on Durus_.
The data is kept in a general structure used by all Schevo databases,
described in the `internal database structures`_ reference.

The database engine is defined in the `schevo.database` module, and
provides read/write access to stored data using the higher-level
structures defined by the database's schema definition.

.. _Durus: http://www.mems-exchange.org/software/durus/

.. _internal database structures: reference-database.html


Schema definition syntax
========================

This section describes the syntax used for schema definitions.


Reserved Words
--------------

The following cannot be used for field names in Entity class
definitions:

- Any single-letter name.  These are reserved for `Namespaces`.

- Any name beginning with an underscore.  These are reserved for
  private methods defined by Schevo.

- Any name beginning with a single letter and an underscore, such as
  ``t_something``.  These are used for query, transaction, view, and
  extender methods.

- ``classmethod``.  This is a decorator used to designate a method as
  attached to a namespace on an entity class's extent, and passed the
  entity class as the first argument when called.

- ``db``.  This contains the currently-open database that the schema
  is associated with.

- ``extentmethod``.  This is a decorator used to designate a method as
  attached to a namespace on an entity class's extent, and passed the
  entity class's extent as the first argument when called.

- ``schevo``.  This is imported into the global namespace.

- ``sys``.  This is used to expose standard public methods and
  properties of Schevo objects. See `sys Namespaces`_.


Preamble
--------

All schemata must begin with the following two lines::

  from schevo.schema import *
  schevo.schema.prep(locals())


Preamble Template
.................

A file is provided in the Schevo source distribution called
``SCHEMA-PREAMBLE.txt`` that contains the source code required for all
Schevo schemata, as well as some additional comments that assist in
starting a new database schema.


Icon Support
............

To include icon support in a database schema, add the following line::

  _import('Schevo', 'icon', 1)


Identity Support
................

To include identity/permission support in a database schema, add the
following line::

  _import('Schevo', 'identity', 1)


Overall Structure
-----------------

A Schevo database schema consists of a series of the following types
of declarations:

- `Entity/extent definitions`_.

- `Field definitions`_.

- `Key/index specifications`_.

- `Query definitions`_ and `query methods`_.

- `Transaction definitions`_ and `transaction methods`_.

- `View definitions`_ and `view methods`_.

- `Extension methods`_.

- `Labels`_.

- `String representations`_.

- `Initial/sample data`_.

Code blocks defined in a schema make use of the `Database API`_.


Schema globals
--------------

The following objects are available in the global Python namespace of
a schema module:

- ``d``: The `schevo.namespace.SchemaDefinition` associated with the
  schema module.

- ``db``: The currently-open `schevo.database.Database` that is using
  the schema module.  See `Database instances`_.


Global namespaces
.................

The following Schevo-managed namespaces are available in the global
Python namespace of a schema module.

Methods defined in the schema definition may use any part of the
`public API <reference-api.html>`__ exposed by the currently opened
database that is associated with the schema.

These namespaces cannot be directly modified.  Schevo manages them,
and automatically adds objects to them when it imports a schema
definition as a module.

- ``E``: `Entity <class-schevo.entity.Entity.html>`__ classes.  The
  standard Entity class is in this namespace by default. Each
  entity/extent definition in the schema is added to this namespace.
  See `entity/extent definitions`_.

- ``F``: `Field <class-schevo.field.Field.html>`__ classes.  The field
  classes defined in `schevo.field <module-schevo.field.html>`__ are
  in this namespace by default.  Custom field definitions in the
  schema are added to this namespace.  See `field definitions`_.

- ``f``: `FieldDefinition
  <class-schevo.fieldspec.FieldDefinition.html>`__ constructors.
  These correspond to the classes defined in the ``F`` namespace and
  are used to create field specifications of entities, queries,
  transactions, and views. See `field specifications`_.

- ``Q``: `Query <class-schevo.query.Query.html>`__ classes.  The Query
  class, and all its subclasses defined in `schevo.query
  <module-schevo.query.html>`__, are in this namespace by default.
  Each Query class defined at the database level is added to this
  namespace.  See `query definitions`_.

- ``q``: Database-level query methods.  See `query methods`_.

- ``T``: `Transaction <class-schevo.transaction.Transaction.html>`__
  classes.  The Transaction class, and all its subclasses defined in
  `schevo.transaction <module-schevo.transaction.html>`__, are in this
  namespace by default. See `transaction definitions`_.

- ``t``: Database-level transaction methods.  See `transaction
  methods`_.

- ``V``: `View <class-schevo.view.View.html>`__ classes.  The View
  class, and all its subclasses defined in `schevo.view
  <module-schevo.view.html>`__, are in this namespace by default.
  Each View class defined at the database level is added to this
  namespace.  See `view definitions`_.


Entity/extent definitions
-------------------------

An entity/extent definition minimally consists of a subclass of
``E.Entity``::

    class Foo(E.Entity):
        """Description of Foo."""

The above example defines a ``Foo`` extent, which contains ``Foo``
entities that each have zero fields, as none were defined.

The entity/extent definition may further contain the following types
of declarations:

- `Field specifications`_.  Here is a ``Foo`` extent where each entity
  has a ``name`` field of ``unicode`` type, and a ``FooChild`` extent
  where each entity has a reference to a ``Foo`` entity and also has a
  ``bar`` field of ``integer`` type::

      class Foo(E.Entity):

          name = f.string()

      class FooChild(E.Entity):

          foo = f.entity('Foo')
          bar = f.integer()

- `Calculated field methods`_.  Here is a ``Gender`` extent whose
  entities have a ``count`` field of type ``integer`` that calculates
  the number of ``Person`` entities whose ``gender`` field references
  that ``Gender`` entity::

      class Gender(E.Entity):

          code = f.unicode()
          name = f.unicode()
          @f.integer()
          def count(self):
              return self.sys.count('Person', 'gender')

      class Person(E.Entity):
      
          name = f.unicode()
          gender = f.entity('Gender', required=False)
      
- `Key/index specifications`_.  Here is a ``Person`` extent whose
  entities must have unique values for their ``name`` field, and that
  is also indexed by ``age`` then ``name``::

      class Person(E.Entity):

          name = f.unicode()
          age = f.integer()

          _key(name)
          _index(age, name)

- Extent-specific `query definitions`_ and `query methods`_.

- Entity/extent-specific `transaction definitions`_ and `transaction
  methods`_.

- Entity-specific `view definitions`_ and `view methods`_.

- Entity/extent-specific `extension methods`_.

- Extent `labels`_.  Schevo creates a default singular and plural
  label for extents based on the class name used to define the
  extent.  This may be overridden in the class definition.  Here is a
  ``Person`` extent whose plural label is "People"::

      class Person(E.Entity):
          _plural = u'People'

  Here is a ``TpsReport`` extent whose singular label is
  "T.P.S. Report".  The default plural label is based on the singular
  label, so the plural label for this extent is "T.P.S. Reports"::

      class TpsReport(E.Entity):
          _label = u'T.P.S. Report'

- Entity `string representations`_.  Schevo user interfaces make use
  of string representations of entities when presenting short
  summaries of them.  The default string representation of an entity
  is the value of its ``name`` field if it has one, or the result of
  calling ``repr()`` on the entity if not.  Here is an example of
  a ``FooChild`` extent that has a custom string representation::

      class Foo(E.Entity):

          name = f.string()

      class FooChild(E.Entity):

          foo = f.entity('Foo')
          bar = f.integer()

          def __unicode__(self):
              return u'%s :: %s' % (self.foo, self.bar)

  In the above example, if a ``FooChild`` entity's ``bar`` field value
  was ``12``, and its ``foo`` value referenced a ``Foo`` entity whose
  ``name`` was ``u'abc'``, the result of calling ``unicode()`` on the
  ``FooChild`` entity would be ``u'abc :: 12'``.

- Extent `initial/sample data`_.


Extension methods
-----------------


Initial/sample data
-------------------

Initial and sample data for a child entity can be supplied by
specifying the value of the first key of the parent.  For example::

    class Foo(E.Entity):

        name = f.string()

        _key(name)

        _initial = [
            ('One', ),
            ('Two', ),
            ('Buckle', ),
            ('Shoe', ),
            ]

    class FooChild(E.Entity):

        foo = f.entity('Foo')
        bar = f.string()

        _key(foo, bar)

        _initial = [
            (('One',), 'This is how it starts.'),
            (('Shoe',), 'This is how it ends.'),
            (('Shoe',), 'Need to have two shoes.'),
            (('Shoe',), 'And one for a rainy day.'),
            ]

The appearance of a tuple tells the data generator to find a ``Foo``
entity whose first unique key matches the values supplied in the
tuple.


Field definitions
-----------------


Field specifications
....................


Calculated field methods
........................


Key and index specifications
----------------------------


Labels and plural labels
------------------------


String representations
----------------------


Query definitions
-----------------


Query methods
-------------


Transaction definitions
-----------------------


Customizing standard Create transactions
........................................


Customizing standard Delete transactions
........................................


Customizing standard Update transactions
........................................


Creating new transactions
.........................


Transaction methods
-------------------


View definitions
----------------


View methods
------------


..
     Local Variables:
     mode: rst
     End: 

